package main

import (
	"bytes"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"testing"
)

// This test is fully generated by LLM.

func TestGetEnv(t *testing.T) {
	t.Run("should return the value of the environment variable", func(t *testing.T) {
		os.Setenv("TEST_ENV", "test")
		if GetEnv("TEST_ENV", "default") != "test" {
			t.Errorf("GetEnv returned %s, expected %s", GetEnv("TEST_ENV", "default"), "test")
		}
	})
}

func TestUploadTaskOutput(t *testing.T) {
	tmpDir := t.TempDir()
	os.Setenv(storageDirKey, tmpDir)
	defer os.Unsetenv(storageDirKey)

	t.Run("should upload file successfully", func(t *testing.T) {
		req := httptest.NewRequest("PUT", "/v1/cache/testhash", bytes.NewBufferString("test content"))
		req.Header.Set("Content-Length", "12")
		req.SetPathValue("hash", "testhash")
		w := httptest.NewRecorder()

		UploadTaskOutput(w, req)

		if w.Code != http.StatusOK {
			t.Errorf("expected status %d, got %d", http.StatusOK, w.Code)
		}

		filePath := filepath.Join(tmpDir, "testhash.cache")
		if _, err := os.Stat(filePath); os.IsNotExist(err) {
			t.Error("file was not created")
		}
	})

	t.Run("should return error when Content-Length is missing", func(t *testing.T) {
		req := httptest.NewRequest("PUT", "/v1/cache/testhash2", bytes.NewBufferString("test"))
		req.SetPathValue("hash", "testhash2")
		w := httptest.NewRecorder()

		UploadTaskOutput(w, req)

		if w.Code != http.StatusBadRequest {
			t.Errorf("expected status %d, got %d", http.StatusBadRequest, w.Code)
		}
	})

	t.Run("should return error when file already exists", func(t *testing.T) {
		filePath := filepath.Join(tmpDir, "existing.cache")
		os.WriteFile(filePath, []byte("existing"), 0644)

		req := httptest.NewRequest("PUT", "/v1/cache/existing", bytes.NewBufferString("new content"))
		req.Header.Set("Content-Length", "11")
		req.SetPathValue("hash", "existing")
		w := httptest.NewRecorder()

		UploadTaskOutput(w, req)

		if w.Code != http.StatusConflict {
			t.Errorf("expected status %d, got %d", http.StatusConflict, w.Code)
		}
	})
}

func TestDownloadTaskOutput(t *testing.T) {
	tmpDir := t.TempDir()
	os.Setenv(storageDirKey, tmpDir)
	defer os.Unsetenv(storageDirKey)

	t.Run("should download file successfully", func(t *testing.T) {
		filePath := filepath.Join(tmpDir, "testhash.cache")
		os.WriteFile(filePath, []byte("test content"), 0644)

		req := httptest.NewRequest("GET", "/v1/cache/testhash", nil)
		req.SetPathValue("hash", "testhash")
		w := httptest.NewRecorder()

		DownloadTaskOutput(w, req)

		if w.Code != http.StatusOK {
			t.Errorf("expected status %d, got %d", http.StatusOK, w.Code)
		}
		if w.Body.String() != "test content" {
			t.Errorf("expected body 'test content', got '%s'", w.Body.String())
		}
	})

	t.Run("should return error when file not found", func(t *testing.T) {
		req := httptest.NewRequest("GET", "/v1/cache/nonexistent", nil)
		req.SetPathValue("hash", "nonexistent")
		w := httptest.NewRecorder()

		DownloadTaskOutput(w, req)

		if w.Code != http.StatusNotFound {
			t.Errorf("expected status %d, got %d", http.StatusNotFound, w.Code)
		}
	})
}

func TestCheckBearerTokenMiddleware(t *testing.T) {
	handler := func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	}

	t.Run("should allow request when no token is configured", func(t *testing.T) {
		os.Unsetenv(authTokenKey)
		middleware := CheckBearerTokenMiddleware(handler)

		req := httptest.NewRequest("GET", "/", nil)
		w := httptest.NewRecorder()

		middleware(w, req)

		if w.Code != http.StatusOK {
			t.Errorf("expected status %d, got %d", http.StatusOK, w.Code)
		}
	})

	t.Run("should allow request with valid token", func(t *testing.T) {
		os.Setenv(authTokenKey, "test-token")
		defer os.Unsetenv(authTokenKey)
		middleware := CheckBearerTokenMiddleware(handler)

		req := httptest.NewRequest("GET", "/", nil)
		req.Header.Set("Authorization", "Bearer test-token")
		w := httptest.NewRecorder()

		middleware(w, req)

		if w.Code != http.StatusOK {
			t.Errorf("expected status %d, got %d", http.StatusOK, w.Code)
		}
	})

	t.Run("should reject request with invalid token", func(t *testing.T) {
		os.Setenv(authTokenKey, "test-token")
		defer os.Unsetenv(authTokenKey)
		middleware := CheckBearerTokenMiddleware(handler)

		req := httptest.NewRequest("GET", "/", nil)
		req.Header.Set("Authorization", "Bearer wrong-token")
		w := httptest.NewRecorder()

		middleware(w, req)

		if w.Code != http.StatusUnauthorized {
			t.Errorf("expected status %d, got %d", http.StatusUnauthorized, w.Code)
		}
	})

	t.Run("should reject request without Authorization header", func(t *testing.T) {
		os.Setenv(authTokenKey, "test-token")
		defer os.Unsetenv(authTokenKey)
		middleware := CheckBearerTokenMiddleware(handler)

		req := httptest.NewRequest("GET", "/", nil)
		w := httptest.NewRecorder()

		middleware(w, req)

		if w.Code != http.StatusUnauthorized {
			t.Errorf("expected status %d, got %d", http.StatusUnauthorized, w.Code)
		}
	})
}

func TestHandleHealth(t *testing.T) {
	req := httptest.NewRequest("GET", "/health", nil)
	w := httptest.NewRecorder()

	HandleHealth(w, req)

	if w.Code != http.StatusOK {
		t.Errorf("expected status %d, got %d", http.StatusOK, w.Code)
	}
	if w.Body.String() != "OK" {
		t.Errorf("expected body 'OK', got '%s'", w.Body.String())
	}
}

func TestHandleTask(t *testing.T) {
	tmpDir := t.TempDir()
	os.Setenv(storageDirKey, tmpDir)
	defer os.Unsetenv(storageDirKey)

	t.Run("should handle PUT request", func(t *testing.T) {
		req := httptest.NewRequest("PUT", "/v1/cache/testhash", bytes.NewBufferString("test"))
		req.Header.Set("Content-Length", "4")
		req.SetPathValue("hash", "testhash")
		w := httptest.NewRecorder()

		HandleTask(w, req)

		if w.Code != http.StatusOK {
			t.Errorf("expected status %d, got %d", http.StatusOK, w.Code)
		}
	})

	t.Run("should handle GET request", func(t *testing.T) {
		filePath := filepath.Join(tmpDir, "testhash2.cache")
		os.WriteFile(filePath, []byte("test"), 0644)

		req := httptest.NewRequest("GET", "/v1/cache/testhash2", nil)
		req.SetPathValue("hash", "testhash2")
		w := httptest.NewRecorder()

		HandleTask(w, req)

		if w.Code != http.StatusOK {
			t.Errorf("expected status %d, got %d", http.StatusOK, w.Code)
		}
	})

	t.Run("should reject unsupported method", func(t *testing.T) {
		req := httptest.NewRequest("POST", "/v1/cache/testhash", nil)
		req.SetPathValue("hash", "testhash")
		w := httptest.NewRecorder()

		HandleTask(w, req)

		if w.Code != http.StatusMethodNotAllowed {
			t.Errorf("expected status %d, got %d", http.StatusMethodNotAllowed, w.Code)
		}
	})
}
